/*
 * Riot API
 *  OpenAPI/Swagger version of the [Riot API](https://developer.riotgames.com/). Automatically generated daily. ## OpenAPI Spec File The following versions of the Riot API spec file are available: - `openapi-3.0.0.json` ([view file](../openapi-3.0.0.json), [ui select](?url=../openapi-3.0.0.json)) - `openapi-3.0.0.min.json` ([view file](../openapi-3.0.0.min.json), [ui select](?url=../openapi-3.0.0.min.json)) - `openapi-3.0.0.yml` ([view file](../openapi-3.0.0.yml), [ui select](?url=../openapi-3.0.0.yml)) - `openapi-3.0.0.min.yml` ([view file](../openapi-3.0.0.min.yml), [ui select](?url=../openapi-3.0.0.min.yml)) - `swaggerspec-2.0.json` ([view file](../swaggerspec-2.0.json), [ui select](?url=../swaggerspec-2.0.json)) - `swaggerspec-2.0.min.json` ([view file](../swaggerspec-2.0.min.json), [ui select](?url=../swaggerspec-2.0.min.json)) - `swaggerspec-2.0.yml` ([view file](../swaggerspec-2.0.yml), [ui select](?url=../swaggerspec-2.0.yml)) - `swaggerspec-2.0.min.yml` ([view file](../swaggerspec-2.0.min.yml), [ui select](?url=../swaggerspec-2.0.min.yml)) ## Other Files - Missing DTOs: [`missing.json`](../missing.json) - Routes Table: [`routesTable.json`](../routesTable.json) - [Enum Files](../enums/) ## Source Code Source code on [GitHub](https://github.com/MingweiSamuel/riotapi-schema). Pull requests welcome! ## Automatically Generated Rebuilt on [Travis CI](https://travis-ci.com/MingweiSamuel/riotapi-schema/builds) daily. *** 
 *
 * The version of the OpenAPI document: 879affafe206ccc5b48127e68c0bd466fcc73c84
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package fr.pajonti.sejuapi.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import fr.pajonti.sejuapi.invoker.JSON;

/**
 * TournamentStubV5TournamentCodeParametersV5
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-14T18:28:23.553111400+01:00[Europe/Paris]", comments = "Generator version: 7.4.0")
public class TournamentStubV5TournamentCodeParametersV5 {
  public static final String SERIALIZED_NAME_ALLOWED_PARTICIPANTS = "allowedParticipants";
  @SerializedName(SERIALIZED_NAME_ALLOWED_PARTICIPANTS)
  private List<String> allowedParticipants;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private String metadata;

  public static final String SERIALIZED_NAME_TEAM_SIZE = "teamSize";
  @SerializedName(SERIALIZED_NAME_TEAM_SIZE)
  private Integer teamSize;

  /**
   * The pick type of the game.              (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)
   */
  @JsonAdapter(PickTypeEnum.Adapter.class)
  public enum PickTypeEnum {
    BLIND_PICK("BLIND_PICK"),
    
    DRAFT_MODE("DRAFT_MODE"),
    
    ALL_RANDOM("ALL_RANDOM"),
    
    TOURNAMENT_DRAFT("TOURNAMENT_DRAFT");

    private String value;

    PickTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PickTypeEnum fromValue(String value) {
      for (PickTypeEnum b : PickTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PickTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PickTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PickTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PickTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PickTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PICK_TYPE = "pickType";
  @SerializedName(SERIALIZED_NAME_PICK_TYPE)
  private PickTypeEnum pickType;

  /**
   * The map type of the game.              (Legal values:  SUMMONERS_RIFT,  HOWLING_ABYSS)
   */
  @JsonAdapter(MapTypeEnum.Adapter.class)
  public enum MapTypeEnum {
    SUMMONERS_RIFT("SUMMONERS_RIFT"),
    
    HOWLING_ABYSS("HOWLING_ABYSS");

    private String value;

    MapTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MapTypeEnum fromValue(String value) {
      for (MapTypeEnum b : MapTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MapTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MapTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MapTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MapTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MapTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MAP_TYPE = "mapType";
  @SerializedName(SERIALIZED_NAME_MAP_TYPE)
  private MapTypeEnum mapType;

  /**
   * The spectator type of the game.              (Legal values:  NONE,  LOBBYONLY,  ALL)
   */
  @JsonAdapter(SpectatorTypeEnum.Adapter.class)
  public enum SpectatorTypeEnum {
    NONE("NONE"),
    
    LOBBYONLY("LOBBYONLY"),
    
    ALL("ALL");

    private String value;

    SpectatorTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SpectatorTypeEnum fromValue(String value) {
      for (SpectatorTypeEnum b : SpectatorTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SpectatorTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SpectatorTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SpectatorTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SpectatorTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SpectatorTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SPECTATOR_TYPE = "spectatorType";
  @SerializedName(SERIALIZED_NAME_SPECTATOR_TYPE)
  private SpectatorTypeEnum spectatorType;

  public static final String SERIALIZED_NAME_ENOUGH_PLAYERS = "enoughPlayers";
  @SerializedName(SERIALIZED_NAME_ENOUGH_PLAYERS)
  private Boolean enoughPlayers;

  public TournamentStubV5TournamentCodeParametersV5() {
  }

  public TournamentStubV5TournamentCodeParametersV5 allowedParticipants(List<String> allowedParticipants) {
    this.allowedParticipants = allowedParticipants;
    return this;
  }

  public TournamentStubV5TournamentCodeParametersV5 addAllowedParticipantsItem(String allowedParticipantsItem) {
    if (this.allowedParticipants == null) {
      this.allowedParticipants = new ArrayList<>();
    }
    this.allowedParticipants.add(allowedParticipantsItem);
    return this;
  }

   /**
   * Optional list of encrypted puuids in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future.
   * @return allowedParticipants
  **/
  @javax.annotation.Nullable
  public List<String> getAllowedParticipants() {
    return allowedParticipants;
  }

  public void setAllowedParticipants(List<String> allowedParticipants) {
    this.allowedParticipants = allowedParticipants;
  }


  public TournamentStubV5TournamentCodeParametersV5 metadata(String metadata) {
    this.metadata = metadata;
    return this;
  }

   /**
   * Optional string that may contain any data in any format, if specified at all. Used to denote any custom information about the game.
   * @return metadata
  **/
  @javax.annotation.Nullable
  public String getMetadata() {
    return metadata;
  }

  public void setMetadata(String metadata) {
    this.metadata = metadata;
  }


  public TournamentStubV5TournamentCodeParametersV5 teamSize(Integer teamSize) {
    this.teamSize = teamSize;
    return this;
  }

   /**
   * The team size of the game. Valid values are 1-5.
   * minimum: 1
   * maximum: 5
   * @return teamSize
  **/
  @javax.annotation.Nonnull
  public Integer getTeamSize() {
    return teamSize;
  }

  public void setTeamSize(Integer teamSize) {
    this.teamSize = teamSize;
  }


  public TournamentStubV5TournamentCodeParametersV5 pickType(PickTypeEnum pickType) {
    this.pickType = pickType;
    return this;
  }

   /**
   * The pick type of the game.              (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT)
   * @return pickType
  **/
  @javax.annotation.Nonnull
  public PickTypeEnum getPickType() {
    return pickType;
  }

  public void setPickType(PickTypeEnum pickType) {
    this.pickType = pickType;
  }


  public TournamentStubV5TournamentCodeParametersV5 mapType(MapTypeEnum mapType) {
    this.mapType = mapType;
    return this;
  }

   /**
   * The map type of the game.              (Legal values:  SUMMONERS_RIFT,  HOWLING_ABYSS)
   * @return mapType
  **/
  @javax.annotation.Nonnull
  public MapTypeEnum getMapType() {
    return mapType;
  }

  public void setMapType(MapTypeEnum mapType) {
    this.mapType = mapType;
  }


  public TournamentStubV5TournamentCodeParametersV5 spectatorType(SpectatorTypeEnum spectatorType) {
    this.spectatorType = spectatorType;
    return this;
  }

   /**
   * The spectator type of the game.              (Legal values:  NONE,  LOBBYONLY,  ALL)
   * @return spectatorType
  **/
  @javax.annotation.Nonnull
  public SpectatorTypeEnum getSpectatorType() {
    return spectatorType;
  }

  public void setSpectatorType(SpectatorTypeEnum spectatorType) {
    this.spectatorType = spectatorType;
  }


  public TournamentStubV5TournamentCodeParametersV5 enoughPlayers(Boolean enoughPlayers) {
    this.enoughPlayers = enoughPlayers;
    return this;
  }

   /**
   * Checks if allowed participants are enough to make full teams.
   * @return enoughPlayers
  **/
  @javax.annotation.Nonnull
  public Boolean getEnoughPlayers() {
    return enoughPlayers;
  }

  public void setEnoughPlayers(Boolean enoughPlayers) {
    this.enoughPlayers = enoughPlayers;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TournamentStubV5TournamentCodeParametersV5 tournamentStubV5TournamentCodeParametersV5 = (TournamentStubV5TournamentCodeParametersV5) o;
    return Objects.equals(this.allowedParticipants, tournamentStubV5TournamentCodeParametersV5.allowedParticipants) &&
        Objects.equals(this.metadata, tournamentStubV5TournamentCodeParametersV5.metadata) &&
        Objects.equals(this.teamSize, tournamentStubV5TournamentCodeParametersV5.teamSize) &&
        Objects.equals(this.pickType, tournamentStubV5TournamentCodeParametersV5.pickType) &&
        Objects.equals(this.mapType, tournamentStubV5TournamentCodeParametersV5.mapType) &&
        Objects.equals(this.spectatorType, tournamentStubV5TournamentCodeParametersV5.spectatorType) &&
        Objects.equals(this.enoughPlayers, tournamentStubV5TournamentCodeParametersV5.enoughPlayers);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowedParticipants, metadata, teamSize, pickType, mapType, spectatorType, enoughPlayers);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TournamentStubV5TournamentCodeParametersV5 {\n");
    sb.append("    allowedParticipants: ").append(toIndentedString(allowedParticipants)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    teamSize: ").append(toIndentedString(teamSize)).append("\n");
    sb.append("    pickType: ").append(toIndentedString(pickType)).append("\n");
    sb.append("    mapType: ").append(toIndentedString(mapType)).append("\n");
    sb.append("    spectatorType: ").append(toIndentedString(spectatorType)).append("\n");
    sb.append("    enoughPlayers: ").append(toIndentedString(enoughPlayers)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowedParticipants");
    openapiFields.add("metadata");
    openapiFields.add("teamSize");
    openapiFields.add("pickType");
    openapiFields.add("mapType");
    openapiFields.add("spectatorType");
    openapiFields.add("enoughPlayers");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("teamSize");
    openapiRequiredFields.add("pickType");
    openapiRequiredFields.add("mapType");
    openapiRequiredFields.add("spectatorType");
    openapiRequiredFields.add("enoughPlayers");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to TournamentStubV5TournamentCodeParametersV5
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TournamentStubV5TournamentCodeParametersV5.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TournamentStubV5TournamentCodeParametersV5 is not found in the empty JSON string", TournamentStubV5TournamentCodeParametersV5.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TournamentStubV5TournamentCodeParametersV5.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TournamentStubV5TournamentCodeParametersV5` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TournamentStubV5TournamentCodeParametersV5.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("allowedParticipants") != null && !jsonObj.get("allowedParticipants").isJsonNull() && !jsonObj.get("allowedParticipants").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowedParticipants` to be an array in the JSON string but got `%s`", jsonObj.get("allowedParticipants").toString()));
      }
      if ((jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) && !jsonObj.get("metadata").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metadata` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metadata").toString()));
      }
      if (!jsonObj.get("pickType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pickType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pickType").toString()));
      }
      // validate the required field `pickType`
      PickTypeEnum.validateJsonElement(jsonObj.get("pickType"));
      if (!jsonObj.get("mapType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mapType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mapType").toString()));
      }
      // validate the required field `mapType`
      MapTypeEnum.validateJsonElement(jsonObj.get("mapType"));
      if (!jsonObj.get("spectatorType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `spectatorType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("spectatorType").toString()));
      }
      // validate the required field `spectatorType`
      SpectatorTypeEnum.validateJsonElement(jsonObj.get("spectatorType"));
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TournamentStubV5TournamentCodeParametersV5.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TournamentStubV5TournamentCodeParametersV5' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TournamentStubV5TournamentCodeParametersV5> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TournamentStubV5TournamentCodeParametersV5.class));

       return (TypeAdapter<T>) new TypeAdapter<TournamentStubV5TournamentCodeParametersV5>() {
           @Override
           public void write(JsonWriter out, TournamentStubV5TournamentCodeParametersV5 value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TournamentStubV5TournamentCodeParametersV5 read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TournamentStubV5TournamentCodeParametersV5 given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TournamentStubV5TournamentCodeParametersV5
  * @throws IOException if the JSON string is invalid with respect to TournamentStubV5TournamentCodeParametersV5
  */
  public static TournamentStubV5TournamentCodeParametersV5 fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TournamentStubV5TournamentCodeParametersV5.class);
  }

 /**
  * Convert an instance of TournamentStubV5TournamentCodeParametersV5 to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

